<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>250mesh Guardian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- MapLibre GL JS の読み込み -->
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <!-- Turf.js（ジオメトリ処理用）の読み込み -->
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    /* 上部パネル */
    #topPanel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      transition: background 1s;
    }
    #topPanel button {
      margin-top: 5px;
      margin-right: 5px;
    }
    /* 残りメッシュ数表示用 */
    #remaining {
      margin-top: 5px;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <!-- スコア表示、残りメッシュ数＆リセット・シェアボタン用パネル -->
  <div id="topPanel">
    <div id="score">Score: 0</div>
    <div id="remaining">Remaining: 0</div>
    <button id="resetBtn">Reset</button>
    <button id="shareBtn" disabled>Share on X</button>
    <div id="gameMessage" style="margin-top:5px; font-weight:bold; color:red;"></div>
  </div>
  
  <div id="map"></div>
  
  <script>
    // MapLibre の初期化（OSMbright スタイルを利用）
    const map = new maplibregl.Map({
      container: 'map',
      // OSMbright のスタイルURL（CDN版）
      style: 'https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json',
      center: [139.6917, 35.6895],
      zoom: 10
    });
    
    // GeoJSON のパス（実際のパスに合わせてください）
    const municipalityUrl = 'municipalities.geojson'; // 自治体境界の GeoJSON
    const meshDataUrl = 'pop_Osakacity_yodogawku.geojson'; // 人口データファイル
    
    // グローバル変数
    let municipalityData = null;
    let meshData = null;
    let score = 0;
    let gameOver = false;
    let q3Value = 0;
    let currentMunicipality = null;
    let municipalityMeshes = null;
    let safeTotal = 0;        // 安全な（高人口でない）メッシュ総数
    let safeClickedCount = 0; // クリック済みの安全メッシュ数
    
    // 残りクリック可能なメッシュ数表示の更新
    function updateRemainingDisplay() {
      const remaining = safeTotal - safeClickedCount;
      document.getElementById('remaining').innerText = 'Remaining: ' + remaining;
    }
    
    // スコア表示更新
    function updateScoreDisplay() {
      document.getElementById('score').innerText = 'Score: ' + score;
    }
    
    // お祝いアクション（例：上部パネルの背景色をゴールドに一瞬変更）
    function celebrate() {
      const topPanel = document.getElementById('topPanel');
      topPanel.style.background = "gold";
      setTimeout(() => {
        topPanel.style.background = "rgba(255,255,255,0.9)";
      }, 1000);
    }
    
    // シェアボタン有効化
    function enableShareButton() {
      document.getElementById('shareBtn').disabled = false;
    }
    
    // X（旧Twitter）に投稿する処理
    function shareOnX() {
      let message = document.getElementById("gameMessage").innerText;
      if (!message) {
        message = "250mesh Guardian: Score " + score;
      }
      const shareUrl = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(message + " #250meshGuardian");
      window.open(shareUrl, "_blank");
    }
    
    // ゲーム開始／リセット時の初期化処理
    function startGame() {
      // 既存のレイヤーやソースがあれば削除
      if (map.getLayer('meshes-layer')) {
        map.off('click', 'meshes-layer', handleMeshClick);
        map.removeLayer('meshes-layer');
      }
      if (map.getSource('meshes')) {
        map.removeSource('meshes');
      }
      
      // 状態初期化
      gameOver = false;
      score = 0;
      safeClickedCount = 0;
      updateScoreDisplay();
      document.getElementById('gameMessage').innerText = "";
      document.getElementById('shareBtn').disabled = true;
      
      // 自治体データからランダムに1件選択
      const features = municipalityData.features;
      currentMunicipality = features[Math.floor(Math.random() * features.length)];
      console.log("選択された自治体:", currentMunicipality.properties.name);
      
      // 自治体のバウンディングボックスで地図をフィット
      const bbox = turf.bbox(currentMunicipality);
      map.fitBounds(bbox, { padding: 20 });
      
      // 人口データ内のメッシュのうち、自治体内のものを抽出（重心で判定）
      const meshesInMunicipality = meshData.features.filter(feature => {
        const centroid = turf.centroid(feature).geometry.coordinates;
        return turf.booleanPointInPolygon(centroid, currentMunicipality);
      });
      
      if (meshesInMunicipality.length === 0) {
        console.error("選択された自治体内にメッシュがありません");
        return;
      }
      
      // 第3四分位数（75パーセンタイル）の計算
      // ※ メッシュ人口は "T001142001_人口（総数）" プロパティを使用
      const populations = meshesInMunicipality.map(f => f.properties["T001142001_人口（総数）"]);
      populations.sort((a, b) => a - b);
      const q3Index = Math.floor(0.75 * populations.length);
      q3Value = populations[q3Index];
      console.log('第3四分位数の人口:', q3Value);
      
      // 安全なメッシュ（高人口以外）の総数を計算
      safeTotal = meshesInMunicipality.filter(f => f.properties["T001142001_人口（総数）"] < q3Value).length;
      console.log('クリック可能な安全メッシュ数:', safeTotal);
      updateRemainingDisplay();
      
      // 自治体内のメッシュをまとめた GeoJSON を作成
      municipalityMeshes = {
        "type": "FeatureCollection",
        "features": meshesInMunicipality
      };
      
      // 各メッシュに一意な id を付与（feature state 利用のため）
      municipalityMeshes.features.forEach((feature, i) => {
        feature.id = i;
      });
      
      // GeoJSON ソース追加
      map.addSource('meshes', {
        type: 'geojson',
        data: municipalityMeshes
      });
      
      // メッシュレイヤー追加
      // ※ fill-color は安全クリック済みなら透明、未クリックなら半透明の白
      map.addLayer({
        id: 'meshes-layer',
        type: 'fill',
        source: 'meshes',
        layout: {},
        paint: {
          'fill-color': [
            "case",
            ["boolean", ["feature-state", "safeClicked"], false],
            "rgba(255,255,255,0)",
            "rgba(255,255,255,0.5)"
          ],
          'fill-outline-color': 'rgba(0,0,0,0.5)'
        }
      });
      
      // クリックイベントのバインド
      map.on('click', 'meshes-layer', handleMeshClick);
      
      // カーソル変更
      map.on('mouseenter', 'meshes-layer', () => {
        map.getCanvas().style.cursor = 'pointer';
      });
      map.on('mouseleave', 'meshes-layer', () => {
        map.getCanvas().style.cursor = '';
      });
    }
    
    // メッシュクリック時の処理
    function handleMeshClick(e) {
      if (gameOver) return;
      if (!e.features || e.features.length === 0) return;
      
      const clickedFeature = e.features[0];
      const state = map.getFeatureState({ source: 'meshes', id: clickedFeature.id });
      if (state && state.safeClicked) return;
      
      // ※ 人口プロパティ "T001142001_人口（総数）" を使用
      const pop = clickedFeature.properties["T001142001_人口（総数）"];
      console.log("クリックされたメッシュの人口:", pop);
      
      if (pop >= q3Value) {
        const remainingSafe = safeTotal - safeClickedCount;
        document.getElementById('gameMessage').innerText = 
          'Game Over! 高人口メッシュをクリックしました。残りのクリック可能な安全メッシュ数: ' + remainingSafe;
        gameOver = true;
        map.off('click', 'meshes-layer', handleMeshClick);
        enableShareButton();
      } else {
        map.setFeatureState({ source: 'meshes', id: clickedFeature.id }, { safeClicked: true });
        score++;
        safeClickedCount++;
        updateScoreDisplay();
        updateRemainingDisplay();
        
        // すべての安全メッシュがクリックされた場合 → クリア
        if (safeClickedCount >= safeTotal) {
          document.getElementById('gameMessage').innerText = 'Clear!!';
          gameOver = true;
          map.off('click', 'meshes-layer', handleMeshClick);
          celebrate();
          enableShareButton();
        }
      }
    }
    
    // リセットボタンの処理
    document.getElementById('resetBtn').addEventListener('click', () => {
      map.off('click', 'meshes-layer', handleMeshClick);
      if (map.getLayer('meshes-layer')) { map.removeLayer('meshes-layer'); }
      if (map.getSource('meshes')) { map.removeSource('meshes'); }
      startGame();
    });
    
    // シェアボタンの処理
    document.getElementById('shareBtn').addEventListener('click', shareOnX);
    
    // マップ読み込み後、自治体・メッシュデータを取得してゲーム開始
    map.on('load', function() {
      Promise.all([
        fetch(municipalityUrl).then(res => res.json()),
        fetch(meshDataUrl).then(res => res.json())
      ]).then(results => {
        municipalityData = results[0];
        meshData = results[1];
        startGame();
      }).catch(err => console.error("データ読み込みエラー:", err));
    });
  </script>
</body>
</html>
